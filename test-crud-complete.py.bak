#!/usr/bin/env python3
"""
Script de Teste CRUD Completo - Odowell
Testa todas as operações em todas as tabelas
"""

import requests
import json
import sys
from datetime import datetime, timedelta
from typing import Dict, List, Tuple

# Configuração
API_URL = "https://api.odowell.pro/api"
TEST_USER = {
    "email": "wasolutionscorp@gmail.com",
    "password": "Senha123"
}

class Colors:
    GREEN = '\033[92m'
    RED = '\033[91m'
    YELLOW = '\033[93m'
    BLUE = '\033[94m'
    END = '\033[0m'
    BOLD = '\033[1m'

class OdowellTester:
    def __init__(self):
        self.token = None
        self.tenant_id = None
        self.user_id = None
        self.results = {
            "total": 0,
            "passed": 0,
            "failed": 0,
            "errors": []
        }
        self.created_ids = {}  # Armazena IDs criados para limpeza

    def log(self, message: str, color: str = ""):
        """Log com cor"""
        timestamp = datetime.now().strftime("%H:%M:%S")
        print(f"{color}[{timestamp}] {message}{Colors.END}")

    def log_success(self, message: str):
        self.log(f"✓ {message}", Colors.GREEN)

    def log_error(self, message: str):
        self.log(f"✗ {message}", Colors.RED)

    def log_info(self, message: str):
        self.log(f"ℹ {message}", Colors.BLUE)

    def log_warning(self, message: str):
        self.log(f"⚠ {message}", Colors.YELLOW)

    def test(self, name: str):
        """Decorator para testes"""
        self.results["total"] += 1
        self.log_info(f"Testando: {name}")

    def assert_equal(self, actual, expected, field_name: str):
        """Valida igualdade"""
        if actual == expected:
            self.results["passed"] += 1
            self.log_success(f"  {field_name}: {actual} ✓")
            return True
        else:
            self.results["failed"] += 1
            error = f"  {field_name}: esperado {expected}, recebido {actual}"
            self.log_error(error)
            self.results["errors"].append(error)
            return False

    def login(self) -> bool:
        """Faz login e obtém token"""
        self.test("Login")
        try:
            response = requests.post(
                f"{API_URL}/auth/login",
                json=TEST_USER,
                timeout=10,
                verify=True
            )

            if response.status_code == 200:
                data = response.json()
                self.token = data.get("token")
                self.tenant_id = data.get("tenant", {}).get("id")
                self.user_id = data.get("user", {}).get("id")

                self.log_success(f"Login realizado com sucesso")
                self.log_info(f"  Token: {self.token[:20]}...")
                self.log_info(f"  Tenant ID: {self.tenant_id}")
                self.log_info(f"  User ID: {self.user_id}")
                return True
            else:
                self.log_error(f"Login falhou: {response.status_code}")
                self.log_error(f"  Resposta: {response.text}")
                return False

        except Exception as e:
            self.log_error(f"Erro no login: {str(e)}")
            return False

    def headers(self) -> Dict:
        """Retorna headers com token"""
        return {
            "Authorization": f"Bearer {self.token}",
            "Content-Type": "application/json"
        }

    def test_crud_patients(self) -> bool:
        """Testa CRUD completo de pacientes"""
        self.log_info("")
        self.log(f"{Colors.BOLD}{'='*60}{Colors.END}")
        self.log(f"{Colors.BOLD}TESTANDO: PACIENTES (Patients){Colors.END}")
        self.log(f"{Colors.BOLD}{'='*60}{Colors.END}")

        # CREATE
        self.test("CREATE - Criar paciente")
        patient_data = {
            "name": "Paciente Teste CRUD",
            "cpf": "12345678901",
            "email": "teste@crud.com",
            "phone": "(11) 98765-4321",
            "cell_phone": "(11) 98765-4321",
            "birth_date": "1990-01-01T00:00:00Z",
            "gender": "M",
            "address": "Rua Teste",
            "number": "123",
            "city": "São Paulo",
            "state": "SP",
            "zip_code": "01234-567",
            "allergies": "Nenhuma",
            "medications": "Nenhum",
            "has_insurance": False,
            "active": True
        }

        try:
            response = requests.post(
                f"{API_URL}/patients",
                json=patient_data,
                headers=self.headers(),
                timeout=10
            )

            if response.status_code in [200, 201]:
                response_data = response.json()
                # API retorna {"patient": {...}}
                created = response_data.get("patient", response_data)
                patient_id = created.get("id")
                self.created_ids["patient"] = patient_id

                self.log_success(f"Paciente criado - ID: {patient_id}")
                self.assert_equal(created.get("name"), patient_data["name"], "Nome")
                self.assert_equal(created.get("cpf"), patient_data["cpf"], "CPF")
                self.assert_equal(created.get("email"), patient_data["email"], "Email")
            else:
                self.log_error(f"Falha ao criar paciente: {response.status_code}")
                self.log_error(f"  {response.text}")
                return False

        except Exception as e:
            self.log_error(f"Erro ao criar paciente: {str(e)}")
            return False

        # READ
        self.test("READ - Ler paciente")
        try:
            response = requests.get(
                f"{API_URL}/patients/{patient_id}",
                headers=self.headers(),
                timeout=10
            )

            if response.status_code == 200:
                response_data = response.json()
                patient = response_data.get("patient", response_data)
                self.log_success(f"Paciente lido com sucesso")
                self.assert_equal(patient.get("id"), patient_id, "ID")
                self.assert_equal(patient.get("name"), patient_data["name"], "Nome")
            else:
                self.log_error(f"Falha ao ler paciente: {response.status_code}")
                return False

        except Exception as e:
            self.log_error(f"Erro ao ler paciente: {str(e)}")
            return False

        # UPDATE
        self.test("UPDATE - Atualizar paciente")
        updated_data = patient_data.copy()
        updated_data["name"] = "Paciente Teste EDITADO"
        updated_data["email"] = "editado@crud.com"

        try:
            response = requests.put(
                f"{API_URL}/patients/{patient_id}",
                json=updated_data,
                headers=self.headers(),
                timeout=10
            )

            if response.status_code == 200:
                response_data = response.json()
                updated = response_data.get("patient", response_data)
                self.log_success(f"Paciente atualizado")
                self.assert_equal(updated.get("name"), "Paciente Teste EDITADO", "Nome editado")
                self.assert_equal(updated.get("email"), "editado@crud.com", "Email editado")
            else:
                self.log_error(f"Falha ao atualizar paciente: {response.status_code}")
                return False

        except Exception as e:
            self.log_error(f"Erro ao atualizar paciente: {str(e)}")
            return False

        # VERIFY UPDATE in DB (via GET)
        self.test("VERIFY - Verificar edição persistiu")
        try:
            response = requests.get(
                f"{API_URL}/patients/{patient_id}",
                headers=self.headers(),
                timeout=10
            )

            if response.status_code == 200:
                response_data = response.json()
                patient = response_data.get("patient", response_data)
                self.assert_equal(patient.get("name"), "Paciente Teste EDITADO", "Nome persistiu")
                self.assert_equal(patient.get("email"), "editado@crud.com", "Email persistiu")
                self.log_success("Edição persistiu no banco de dados")
            else:
                self.log_error("Falha ao verificar persistência")
                return False

        except Exception as e:
            self.log_error(f"Erro ao verificar: {str(e)}")
            return False

        return True

    def test_crud_appointments(self) -> bool:
        """Testa CRUD completo de agendamentos"""
        self.log_info("")
        self.log(f"{Colors.BOLD}{'='*60}{Colors.END}")
        self.log(f"{Colors.BOLD}TESTANDO: AGENDAMENTOS (Appointments){Colors.END}")
        self.log(f"{Colors.BOLD}{'='*60}{Colors.END}")

        patient_id = self.created_ids.get("patient")
        if not patient_id:
            self.log_warning("Pulando teste de agendamentos (sem paciente)")
            return True

        # CREATE
        self.test("CREATE - Criar agendamento")
        start_time = (datetime.now() + timedelta(days=1)).strftime("%Y-%m-%dT10:00:00Z")
        end_time = (datetime.now() + timedelta(days=1)).strftime("%Y-%m-%dT11:00:00Z")

        appointment_data = {
            "patient_id": patient_id,
            "dentist_id": self.user_id,
            "start_time": start_time,
            "end_time": end_time,
            "type": "consultation",
            "procedure": "Consulta de rotina",
            "status": "scheduled",
            "notes": "Teste CRUD"
        }

        try:
            response = requests.post(
                f"{API_URL}/appointments",
                json=appointment_data,
                headers=self.headers(),
                timeout=10
            )

            if response.status_code in [200, 201]:
                created = response.json()
                appointment_id = created.get("id")
                self.created_ids["appointment"] = appointment_id

                self.log_success(f"Agendamento criado - ID: {appointment_id}")
                self.assert_equal(created.get("patient_id"), patient_id, "Patient ID")
                self.assert_equal(created.get("type"), "consultation", "Tipo")
            else:
                self.log_error(f"Falha ao criar agendamento: {response.status_code}")
                self.log_error(f"  {response.text}")
                return False

        except Exception as e:
            self.log_error(f"Erro ao criar agendamento: {str(e)}")
            return False

        # READ & UPDATE
        self.test("UPDATE - Atualizar agendamento")
        updated_appointment = appointment_data.copy()
        updated_appointment["status"] = "confirmed"
        updated_appointment["notes"] = "Teste CRUD - EDITADO"

        try:
            response = requests.put(
                f"{API_URL}/appointments/{appointment_id}",
                json=updated_appointment,
                headers=self.headers(),
                timeout=10
            )

            if response.status_code == 200:
                updated = response.json()
                self.log_success(f"Agendamento atualizado")
                self.assert_equal(updated.get("status"), "confirmed", "Status editado")
                self.assert_equal(updated.get("notes"), "Teste CRUD - EDITADO", "Notes editado")
            else:
                self.log_error(f"Falha ao atualizar: {response.status_code}")
                return False

        except Exception as e:
            self.log_error(f"Erro ao atualizar: {str(e)}")
            return False

        # VERIFY
        self.test("VERIFY - Verificar edição de agendamento")
        try:
            response = requests.get(
                f"{API_URL}/appointments/{appointment_id}",
                headers=self.headers(),
                timeout=10
            )

            if response.status_code == 200:
                appointment = response.json()
                self.assert_equal(appointment.get("status"), "confirmed", "Status persistiu")
                self.log_success("Edição de agendamento persistiu")
            else:
                self.log_error("Falha ao verificar")
                return False

        except Exception as e:
            self.log_error(f"Erro: {str(e)}")
            return False

        return True

    def test_crud_budgets(self) -> bool:
        """Testa CRUD completo de orçamentos"""
        self.log_info("")
        self.log(f"{Colors.BOLD}{'='*60}{Colors.END}")
        self.log(f"{Colors.BOLD}TESTANDO: ORÇAMENTOS (Budgets){Colors.END}")
        self.log(f"{Colors.BOLD}{'='*60}{Colors.END}")

        patient_id = self.created_ids.get("patient")
        if not patient_id:
            self.log_warning("Pulando teste de orçamentos (sem paciente)")
            return True

        # CREATE
        self.test("CREATE - Criar orçamento")
        budget_data = {
            "patient_id": patient_id,
            "dentist_id": self.user_id,
            "description": "Orçamento teste CRUD",
            "total_value": 500.00,
            "status": "pending",
            "notes": "Teste CRUD"
        }

        try:
            response = requests.post(
                f"{API_URL}/budgets",
                json=budget_data,
                headers=self.headers(),
                timeout=10
            )

            if response.status_code in [200, 201]:
                created = response.json()
                budget_id = created.get("id")
                self.created_ids["budget"] = budget_id

                self.log_success(f"Orçamento criado - ID: {budget_id}")
                self.assert_equal(created.get("total_value"), 500.00, "Valor")
            else:
                self.log_error(f"Falha ao criar orçamento: {response.status_code}")
                return False

        except Exception as e:
            self.log_error(f"Erro ao criar orçamento: {str(e)}")
            return False

        # UPDATE
        self.test("UPDATE - Atualizar orçamento")
        updated_budget = budget_data.copy()
        updated_budget["status"] = "approved"
        updated_budget["total_value"] = 600.00

        try:
            response = requests.put(
                f"{API_URL}/budgets/{budget_id}",
                json=updated_budget,
                headers=self.headers(),
                timeout=10
            )

            if response.status_code == 200:
                updated = response.json()
                self.log_success(f"Orçamento atualizado")
                self.assert_equal(updated.get("status"), "approved", "Status")
                self.assert_equal(updated.get("total_value"), 600.00, "Valor editado")
            else:
                self.log_error(f"Falha ao atualizar: {response.status_code}")
                return False

        except Exception as e:
            self.log_error(f"Erro: {str(e)}")
            return False

        return True

    def cleanup(self):
        """Limpa dados de teste criados"""
        self.log_info("")
        self.log(f"{Colors.BOLD}{'='*60}{Colors.END}")
        self.log(f"{Colors.BOLD}LIMPEZA (Cleanup){Colors.END}")
        self.log(f"{Colors.BOLD}{'='*60}{Colors.END}")

        # Deletar na ordem correta (dependências)
        endpoints = [
            ("appointment", "appointments"),
            ("budget", "budgets"),
            ("patient", "patients")
        ]

        for key, endpoint in endpoints:
            if key in self.created_ids:
                resource_id = self.created_ids[key]
                try:
                    response = requests.delete(
                        f"{API_URL}/{endpoint}/{resource_id}",
                        headers=self.headers(),
                        timeout=10
                    )

                    if response.status_code in [200, 204]:
                        self.log_success(f"Deletado {key} ID {resource_id}")
                    else:
                        self.log_warning(f"Não foi possível deletar {key}: {response.status_code}")

                except Exception as e:
                    self.log_warning(f"Erro ao deletar {key}: {str(e)}")

    def print_summary(self):
        """Imprime resumo dos testes"""
        self.log_info("")
        self.log(f"{Colors.BOLD}{'='*60}{Colors.END}")
        self.log(f"{Colors.BOLD}RESUMO DOS TESTES{Colors.END}")
        self.log(f"{Colors.BOLD}{'='*60}{Colors.END}")

        total = self.results["total"]
        passed = self.results["passed"]
        failed = self.results["failed"]
        success_rate = (passed / total * 100) if total > 0 else 0

        self.log_info(f"Total de testes: {total}")
        self.log_success(f"Passou: {passed}")

        if failed > 0:
            self.log_error(f"Falhou: {failed}")
        else:
            self.log_success(f"Falhou: {failed}")

        self.log_info(f"Taxa de sucesso: {success_rate:.1f}%")

        if self.results["errors"]:
            self.log_error("\nErros encontrados:")
            for error in self.results["errors"]:
                self.log_error(f"  {error}")

        self.log_info("")
        if failed == 0:
            self.log(f"{Colors.GREEN}{Colors.BOLD}✓ TODOS OS TESTES PASSARAM!{Colors.END}")
            return 0
        else:
            self.log(f"{Colors.RED}{Colors.BOLD}✗ ALGUNS TESTES FALHARAM{Colors.END}")
            return 1

    def run(self):
        """Executa todos os testes"""
        self.log(f"{Colors.BOLD}{'='*60}{Colors.END}")
        self.log(f"{Colors.BOLD}TESTE CRUD COMPLETO - ODOWELL{Colors.END}")
        self.log(f"{Colors.BOLD}{'='*60}{Colors.END}")
        self.log_info(f"API: {API_URL}")
        self.log_info(f"Usuário: {TEST_USER['email']}")
        self.log_info("")

        # Login
        if not self.login():
            self.log_error("Falha no login. Abortando testes.")
            return 1

        # Executar testes
        try:
            self.test_crud_patients()
            self.test_crud_appointments()
            self.test_crud_budgets()
        except KeyboardInterrupt:
            self.log_warning("\nTestes interrompidos pelo usuário")
        except Exception as e:
            self.log_error(f"Erro inesperado: {str(e)}")
        finally:
            # Sempre limpar
            self.cleanup()

        # Resumo
        return self.print_summary()


if __name__ == "__main__":
    tester = OdowellTester()
    exit_code = tester.run()
    sys.exit(exit_code)
